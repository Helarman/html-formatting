{"ast":null,"code":"// Based on package html-parse-stringify2\n// Expanded to handle webcomponents\n\nconst tagRE = /(?:<!--[\\S\\s]*?-->|<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\n\n// See https://regexr.com/6p8p0\nconst attrRE = /(?:\\s(?<boolean>[^/\\s><=]+?)(?=[\\s/>]))|(?:(?<name>\\S+?)(?:\\s*=\\s*(?:(['\"])(?<quotedValue>[\\s\\S]*?)\\3|(?<unquotedValue>[^\\s>]+))))/g;\n//                   ^ capture group 1: boolean attribute name (attributes without values)\n//                                                         ^ capture group 2: non-boolean attribute name\n//                                                                                         ^ capture group 4: non-boolean attribute value with quotes\n//                                                                                                                    ^ capture group 5: non-boolean attribute value without quotes\n// TODO\n//  - \"/\" values in the middle of the HTML tag (they don't self-close the element, but skipped)\n//  - What other cases?\n\nconst lookup = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  menuitem: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\nfunction parseTag( /**@type {string}*/tag) {\n  const res = {\n    type: 'tag',\n    name: '',\n    voidElement: false,\n    attrs: [],\n    children: []\n  };\n  const tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/);\n  if (tagMatch) {\n    res.name = tagMatch[1];\n    if (lookup[tagMatch[1].toLowerCase()] || tag.charAt(tag.length - 2) === '/') {\n      res.voidElement = true;\n    }\n\n    // handle comment tag\n    if (res.name.startsWith('!--')) {\n      const endIndex = tag.indexOf('-->');\n      return {\n        type: 'comment',\n        comment: endIndex !== -1 ? tag.slice(4, endIndex) : ''\n      };\n    }\n  }\n  const reg = new RegExp(attrRE);\n  for (const match of tag.matchAll(reg)) {\n    // TODO named groups method not working yet, groups is undefined in tests (maybe not out in Node.js yet)\n    // const groups = match.groups\n    // res.attrs[groups.boolean || groups.name] = groups.value1 || groups.value2 || \"\"\n    if ((match[1] || match[2]).startsWith('use:')) {\n      res.attrs.push({\n        type: 'directive',\n        name: match[1] || match[2],\n        value: match[4] || match[5] || ''\n      });\n    } else {\n      res.attrs.push({\n        type: 'attr',\n        name: match[1] || match[2],\n        value: match[4] || match[5] || ''\n      });\n    }\n  }\n  return res;\n}\n// common logic for pushing a child node onto a list\nfunction pushTextNode(list, html, start) {\n  // calculate correct end of the content slice in case there's\n  // no tag after the text node.\n  const end = html.indexOf('<', start);\n  const content = html.slice(start, end === -1 ? void 0 : end);\n  if (!/^\\s*$/.test(content)) {\n    list.push({\n      type: 'text',\n      content: content\n    });\n  }\n}\nfunction pushCommentNode(list, tag) {\n  // calculate correct end of the content slice in case there's\n  // no tag after the text node.\n  const content = tag.replace('<!--', '').replace('-->', '');\n  if (!/^\\s*$/.test(content)) {\n    list.push({\n      type: 'comment',\n      content: content\n    });\n  }\n}\nfunction parse(html) {\n  const result = [];\n  let current = void 0;\n  let level = -1;\n  const arr = [];\n  const byTag = {};\n  html.replace(tagRE, (tag, index) => {\n    const isOpen = tag.charAt(1) !== '/';\n    const isComment = tag.slice(0, 4) === '<!--';\n    const start = index + tag.length;\n    const nextChar = html.charAt(start);\n    let parent = void 0;\n    if (isOpen && !isComment) {\n      level++;\n      current = parseTag(tag);\n      if (!current.voidElement && nextChar && nextChar !== '<') {\n        pushTextNode(current.children, html, start);\n      }\n      byTag[current.tagName] = current;\n      // if we're at root, push new base node\n      if (level === 0) {\n        result.push(current);\n      }\n      parent = arr[level - 1];\n      if (parent) {\n        parent.children.push(current);\n      }\n      arr[level] = current;\n    }\n    if (isComment) {\n      if (level < 0) {\n        pushCommentNode(result, tag);\n      } else {\n        pushCommentNode(arr[level].children, tag);\n      }\n    }\n    if (isComment || !isOpen || current.voidElement) {\n      if (!isComment) {\n        level--;\n      }\n      if (nextChar !== '<' && nextChar) {\n        // trailing text node\n        // if we're at the root, push a base text node. otherwise add as\n        // a child to the current node.\n        parent = level === -1 ? result : arr[level].children;\n        pushTextNode(parent, html, start);\n      }\n    }\n  });\n  return result;\n}\n\n// Based on package html-parse-stringify2\n// Expanded to handle webcomponents\n\n/**\n * @param {import('../types/index').IDom['attrs']} attrs \n * @returns {string}\n */\nfunction attrString(attrs) {\n  const buff = [];\n  for (const attr of attrs) {\n    buff.push(attr.name + '=\"' + attr.value.replace(/\"/g, '&quot;') + '\"');\n  }\n  if (!buff.length) {\n    return '';\n  }\n  return ' ' + buff.join(' ');\n}\n/**\n * @param {string} buff \n * @param {import('../types/index').IDom} doc \n * @returns {string}\n */\nfunction stringifier(buff, doc) {\n  switch (doc.type) {\n    case 'text':\n      return buff + doc.content;\n    case 'tag':\n      buff += '<' + doc.name + (doc.attrs ? attrString(doc.attrs) : '') + (doc.voidElement ? '/>' : '>');\n      if (doc.voidElement) {\n        return buff;\n      }\n      return buff + doc.children.reduce(stringifier, '') + '</' + doc.name + '>';\n    case 'comment':\n      return buff += '<!--' + doc.content + '-->';\n  }\n}\n/**\n * @param {import('../types/index').IDom[]} doc \n * @returns {string}\n */\nfunction stringify(doc) {\n  return doc.reduce(function (token, rootEl) {\n    return token + stringifier('', rootEl);\n  }, '');\n}\nexport { parse, stringify };","map":{"version":3,"names":["tagRE","attrRE","lookup","area","base","br","col","embed","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr","parseTag","tag","res","type","name","voidElement","attrs","children","tagMatch","match","toLowerCase","charAt","length","startsWith","endIndex","indexOf","comment","slice","reg","RegExp","matchAll","push","value","pushTextNode","list","html","start","end","content","test","pushCommentNode","replace","parse","result","current","level","arr","byTag","index","isOpen","isComment","nextChar","parent","tagName","attrString","buff","attr","join","stringifier","doc","reduce","stringify","token","rootEl"],"sources":["C:/Users/helarman/Downloads/work/a1/inki-1/node_modules/html-parse-string/dist/index.js"],"sourcesContent":["// Based on package html-parse-stringify2\n// Expanded to handle webcomponents\n\nconst tagRE = /(?:<!--[\\S\\s]*?-->|<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\n\n// See https://regexr.com/6p8p0\nconst attrRE = /(?:\\s(?<boolean>[^/\\s><=]+?)(?=[\\s/>]))|(?:(?<name>\\S+?)(?:\\s*=\\s*(?:(['\"])(?<quotedValue>[\\s\\S]*?)\\3|(?<unquotedValue>[^\\s>]+))))/g;\n//                   ^ capture group 1: boolean attribute name (attributes without values)\n//                                                         ^ capture group 2: non-boolean attribute name\n//                                                                                         ^ capture group 4: non-boolean attribute value with quotes\n//                                                                                                                    ^ capture group 5: non-boolean attribute value without quotes\n// TODO\n//  - \"/\" values in the middle of the HTML tag (they don't self-close the element, but skipped)\n//  - What other cases?\n\n\nconst lookup = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  menuitem: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\nfunction parseTag(/**@type {string}*/tag) {\n  const res = {\n    type: 'tag',\n    name: '',\n    voidElement: false,\n    attrs: [],\n    children: []\n  };\n  const tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/);\n  if (tagMatch) {\n    res.name = tagMatch[1];\n    if (\n      lookup[tagMatch[1].toLowerCase()] ||\n      tag.charAt(tag.length - 2) === '/'\n    ) {\n      res.voidElement = true;\n    }\n\n    // handle comment tag\n    if (res.name.startsWith('!--')) {\n      const endIndex = tag.indexOf('-->');\n      return {\n        type: 'comment',\n        comment: endIndex !== -1 ? tag.slice(4, endIndex) : '',\n      }\n    }\n  }\n\n  const reg = new RegExp(attrRE);\n\n  for (const match of tag.matchAll(reg)) {\n    // TODO named groups method not working yet, groups is undefined in tests (maybe not out in Node.js yet)\n    // const groups = match.groups\n    // res.attrs[groups.boolean || groups.name] = groups.value1 || groups.value2 || \"\"\n    if ((match[1] || match[2]).startsWith('use:')) {\n      res.attrs.push({ type: 'directive', name: match[1] || match[2], value: match[4] || match[5] || '' });\n    } else {\n      res.attrs.push({ type: 'attr', name: match[1] || match[2], value: match[4] || match[5] || '' });\n    }\n  }\n\n  return res\n}\n// common logic for pushing a child node onto a list\nfunction pushTextNode(list, html, start) {\n  // calculate correct end of the content slice in case there's\n  // no tag after the text node.\n  const end = html.indexOf('<', start);\n  const content = html.slice(start, end === -1 ? void 0 : end);\n  if (!/^\\s*$/.test(content)) {\n    list.push({\n      type: 'text',\n      content: content\n    });\n  }\n}\nfunction pushCommentNode(list, tag) {\n  // calculate correct end of the content slice in case there's\n  // no tag after the text node.\n  const content = tag.replace('<!--', '').replace('-->', '');\n  if (!/^\\s*$/.test(content)) {\n    list.push({\n      type: 'comment',\n      content: content\n    });\n  }\n}\n\nfunction parse(html) {\n  const result = [];\n  let current = void 0;\n  let level = -1;\n  const arr = [];\n  const byTag = {};\n  html.replace(tagRE, (tag, index) => {\n    const isOpen = tag.charAt(1) !== '/';\n    const isComment = tag.slice(0, 4) === '<!--';\n    const start = index + tag.length;\n    const nextChar = html.charAt(start);\n    let parent = void 0;\n    if (isOpen && !isComment) {\n      level++;\n      current = parseTag(tag);\n      if (!current.voidElement && nextChar && nextChar !== '<') {\n        pushTextNode(current.children, html, start);\n      }\n      byTag[current.tagName] = current;\n      // if we're at root, push new base node\n      if (level === 0) {\n        result.push(current);\n      }\n      parent = arr[level - 1];\n      if (parent) {\n        parent.children.push(current);\n      }\n      arr[level] = current;\n    }\n    if (isComment) {\n      if (level < 0) {\n        pushCommentNode(result, tag);\n      } else {\n        pushCommentNode(arr[level].children, tag);\n      }\n    }\n    if (isComment || !isOpen || current.voidElement) {\n      if (!isComment) {\n        level--;\n      }\n      if (nextChar !== '<' && nextChar) {\n        // trailing text node\n        // if we're at the root, push a base text node. otherwise add as\n        // a child to the current node.\n        parent = level === -1 ? result : arr[level].children;\n        pushTextNode(parent, html, start);\n      }\n    }\n  });\n  return result;\n}\n\n// Based on package html-parse-stringify2\n// Expanded to handle webcomponents\n\n/**\n * @param {import('../types/index').IDom['attrs']} attrs \n * @returns {string}\n */\nfunction attrString(attrs) {\n  const buff = [];\n  for (const attr of attrs) {\n    buff.push(attr.name + '=\"' + attr.value.replace(/\"/g, '&quot;') + '\"');\n  }\n  if (!buff.length) {\n    return '';\n  }\n  return ' ' + buff.join(' ');\n}\n/**\n * @param {string} buff \n * @param {import('../types/index').IDom} doc \n * @returns {string}\n */\nfunction stringifier(buff, doc) {\n  switch (doc.type) {\n    case 'text':\n      return buff + doc.content;\n    case 'tag':\n      buff += '<' + doc.name + (doc.attrs ? attrString(doc.attrs) : '') + (doc.voidElement ? '/>' : '>');\n      if (doc.voidElement) {\n        return buff;\n      }\n      return buff + doc.children.reduce(stringifier, '') + '</' + doc.name + '>';\n    case 'comment':\n      return buff += '<!--' + doc.content + '-->';\n  }\n}\n/**\n * @param {import('../types/index').IDom[]} doc \n * @returns {string}\n */\nfunction stringify(doc) {\n  return doc.reduce(function (token, rootEl) {\n    return token + stringifier('', rootEl);\n  }, '');\n}\n\nexport { parse, stringify };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}